from math import fabs, sqrtfrom heapq import heappop, heappushdef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """        path = []    boxes = {}    start_box = end_box = None    skip = False    y_start,x_start = source_point    y_end,x_end = destination_point    for box in mesh['boxes']:        y1,y2,x1,x2 = box        if x1 <= x_start <= x2 and y1 <= y_start <= y2:            boxes[box] = 0            start_box = box                    if x1 <= x_end <= x2 and y1 <= y_end <= y2:            boxes[box] = 0            end_box = box    if not start_box or not end_box:        print("there is no path :(")        skip = True    elif start_box == end_box:        path.append((source_point, destination_point))        skip = True    if not skip:        visited, _path = a_star(mesh, start_box, source_point, end_box, destination_point)        for v in visited:            boxes[v] = 0        #no path :(        if _path == None:            print("there is no path :(")        else:                prev = source_point            for p in _path:                path.append((prev, p))                prev = p    return path, boxes.keys()def a_star(mesh, start, start_pos, end, end_pos):    q = []    forward_dist, backward_dist = {}, {}    forward_prev, backward_prev = {}, {}    forward_box_pos, backward_box_pos = {}, {}        heappush(q, (0, start, end))    heappush(q, (0, end, start))        forward_dist[start] = 0    backward_dist[end] = 0        forward_box_pos[start] = start_pos    backward_box_pos[end] = end_pos    found = False    while q:        val, box, goal = heappop(q)        if goal == end:            if box in backward_dist or box == goal:                found = True                break            for next_box in mesh['adj'][box]:                alt, next_box_pos = cost(forward_box_pos[box], next_box)                alt += forward_dist[box]                if next_box not in forward_dist or alt < forward_dist[next_box]:                    forward_dist[next_box] = alt                    forward_prev[next_box] = box                    forward_box_pos[next_box] = next_box_pos                    heappush(q, (alt + est(next_box_pos, end_pos), next_box, goal))        else:            if box in forward_dist or box == goal:                found = True                break            for next_box in mesh['adj'][box]:                alt, next_box_pos = cost(backward_box_pos[box], next_box)                alt += backward_dist[box]                if next_box not in backward_dist or alt < backward_dist[next_box]:                    backward_dist[next_box] = alt                    backward_prev[next_box] = box                    backward_box_pos[next_box] = next_box_pos                    heappush(q, (alt + est(next_box_pos, start_pos), next_box, goal))    if not found:        return set(forward_dist).union(set(backward_dist)), None        path = []    box_copy = box    while box != start:        path.insert(0, forward_box_pos[box])        box = forward_prev[box]    while box_copy != end:        path.append(backward_box_pos[box_copy])        box_copy = backward_prev[box_copy]    path.append(end_pos)    return set(forward_dist).union(set(backward_dist)), pathdef est(box_pos, end_pos):    y, x = box_pos    y1, x1 = end_pos    return sqrt((y1-y)**2 + (x1-x)**2)def cost(pos_in_box, next_box):    min_y, max_y, min_x, max_x = next_box    y, x = pos_in_box    y1 = max(min(y, max_y), min_y)    x1 = max(min(x, max_x), min_x)    return sqrt((y1 - y)**2 + (x1 - x)**2), (y1, x1)